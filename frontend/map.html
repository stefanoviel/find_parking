<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Parking Map</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { width: 100%; height: 100vh; }
    .control-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="control-panel">
    <label for="timeoutInput">Timeout (seconds):</label>
    <input type="number" id="timeoutInput" value="60" min="10" />
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- Proj4 JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.6.2/proj4.js"></script>
  <!-- MarkerClusterGroup JS -->
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script>
    // Define the projection transformation from CH1903+ (LV95) to WGS84
    proj4.defs("EPSG:2056", "+proj=somerc +lat_0=46.952405555556 +lon_0=7.4395833333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0.0,0.0,0.0,0.0 +units=m +no_defs");


    function convertToWGS84(ch_x, ch_y) {
      const [lon, lat] = proj4("EPSG:2056", "EPSG:4326", [ch_x, ch_y]);
      return { lat, lon };
    }

    // Global timeout value (in seconds) read from the input
    let globalTimeout = parseInt(document.getElementById('timeoutInput').value, 10);
    document.getElementById('timeoutInput').addEventListener('change', (e) => {
      globalTimeout = parseInt(e.target.value, 10);
      console.log("Global timeout updated to", globalTimeout, "seconds");
    });

    // Create the map – center and zoom level should be adjusted to your city
    const initialCoords = convertToWGS84(2679750, 1248625); // Center around one of our demo points
    const map = L.map('map', {
      maxZoom: 22  // Increased max zoom level
    }).setView([initialCoords.lat, initialCoords.lon], 16);

    // Add an OpenStreetMap tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 22,  // Match the map's maxZoom
      maxNativeZoom: 19  // This is OSM's max zoom level - tiles will be scaled beyond this
    }).addTo(map);

    // Define custom icons for busy (red) and free (green) parking slots
    const busyIcon = new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    const freeIcon = new L.Icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // Objects to keep track of markers and timers by parking slot id
    const markers = {};
    const timers = {};

    // Helper functions for localStorage persistence
    function saveSlotState(id, state) {
      localStorage.setItem('parkingSlot_' + id, JSON.stringify(state));
    }

    function getSlotState(id) {
      const state = localStorage.getItem('parkingSlot_' + id);
      return state ? JSON.parse(state) : null;
    }

    function removeSlotState(id) {
      localStorage.removeItem('parkingSlot_' + id);
    }

    // Simulate a dummy API call – replace this with your actual API call as needed.
    function dummyApiCall(status, slotId) {
      console.log(`Dummy API call: Parking slot ${slotId} marked as ${status}`);
      // Example:
      // fetch(`https://your-backend.com/api/parking/${slotId}?status=${status}`)
      //   .then(res => res.json())
      //   .then(data => console.log(data))
      //   .catch(err => console.error(err));
    }

    // Mark a parking slot as free: update localStorage, marker icon, call API, and set timer.
    function markSlotFree(slot, marker) {
      const timeoutSeconds = globalTimeout;
      const expirationTime = Date.now() + timeoutSeconds * 1000;
      saveSlotState(slot.id, { free: true, expiration: expirationTime });
      marker.setIcon(freeIcon);
      dummyApiCall('free', slot.id);

      // Clear any existing timer for this slot
      if (timers[slot.id]) {
        clearTimeout(timers[slot.id]);
      }
      // Set a timer to mark the slot busy when timeout expires
      timers[slot.id] = setTimeout(() => {
        markSlotBusy(slot, marker);
      }, timeoutSeconds * 1000);

      // If the popup is open, update the checkbox status
      const checkbox = document.getElementById('freeCheckbox_' + slot.id);
      if (checkbox) {
        checkbox.checked = true;
      }
    }

    // Mark a parking slot as busy: remove free state, update marker icon, and call API.
    function markSlotBusy(slot, marker) {
      removeSlotState(slot.id);
      marker.setIcon(busyIcon);
      dummyApiCall('busy', slot.id);

      if (timers[slot.id]) {
        clearTimeout(timers[slot.id]);
        delete timers[slot.id];
      }

      const checkbox = document.getElementById('freeCheckbox_' + slot.id);
      if (checkbox) {
        checkbox.checked = false;
      }
    }

    // Create HTML for the popup for a parking slot marker
    function createPopupContent(slot, marker) {
      const state = getSlotState(slot.id);
      const isFree = state && state.free && state.expiration > Date.now();
      const checkedAttr = isFree ? 'checked' : '';
      return `
        <div>
          <input type="checkbox" id="freeCheckbox_${slot.id}" ${checkedAttr}>
          <label for="freeCheckbox_${slot.id}">Tick if parking slot is free</label>
        </div>
      `;
    }

    // Attach an event listener to the checkbox inside the popup when it opens.
    function onPopupOpen(e, slot, marker) {
      const checkbox = document.getElementById('freeCheckbox_' + slot.id);
      if (checkbox) {
        checkbox.addEventListener('change', (event) => {
          if (event.target.checked) {
            markSlotFree(slot, marker);
          } else {
            markSlotBusy(slot, marker);
          }
        });
      }
    }

    // Create a marker cluster group with adjusted settings
    const markerClusterGroup = L.markerClusterGroup({
      chunkedLoading: true,
      maxClusterRadius: 120,  // Increased to create fewer clusters
      spiderfyOnMaxZoom: false,  // Disabled to improve performance
      disableClusteringAtZoom: 18, // Lowered to maintain clustering longer
      animate: false,  // Disabled animations for better performance
      removeOutsideVisibleBounds: true,  // Remove clusters/markers outside view
      zoomToBoundsOnClick: true,
      showCoverageOnHover: false  // Disabled for better performance
    });

    // Load parking slots from your backend API
    function loadParkingSlots() {
      fetch('/api/parkings')
        .then(response => response.json())
        .then(data => {
          data.forEach(slot => {
            // Assuming the API returns { id, x, y, ... } where x/y are coordinates.
            // Adjust if necessary (e.g., converting projections).
            const lat = slot.y;
            const lng = slot.x;

            // Check persistent state from localStorage
            const state = getSlotState(slot.id);
            let isFree = false;
            let remainingTime = 0;
            if (state && state.free && state.expiration > Date.now()) {
              isFree = true;
              remainingTime = state.expiration - Date.now();
            }

            const marker = L.marker([lat, lng], { icon: isFree ? freeIcon : busyIcon }).addTo(map);
            markers[slot.id] = marker;
            marker.bindPopup(createPopupContent(slot, marker));
            marker.on('popupopen', (e) => {
              onPopupOpen(e, slot, marker);
            });

            // If the slot is already free, schedule its timer
            if (isFree) {
              if (timers[slot.id]) clearTimeout(timers[slot.id]);
              timers[slot.id] = setTimeout(() => {
                markSlotBusy(slot, marker);
              }, remainingTime);
            }
          });
        })
        .catch(err => console.error('Error loading parking slots:', err));
    }

    // Modify loadParkingSlotsDemo function
    function loadParkingSlotsDemo() {
      fetch('parkings.json')
        .then(response => response.json())
        .then(parkingData => {
          const chunkSize = 200;  // Increased chunk size
          let index = 0;

          function processChunk() {
            const chunk = parkingData.slice(index, index + chunkSize);
            const bounds = map.getBounds().pad(0.5);  // Add padding to reduce edge loading
            
            chunk.forEach(slot => {
              const { lat, lon } = convertToWGS84(slot.x, slot.y);
              
              if (bounds.contains([lat, lon])) {
                // Only create marker if it doesn't already exist
                if (!markers[slot.id]) {
                  const marker = L.marker([lat, lon], { icon: busyIcon });
                  markers[slot.id] = marker;
                  marker.bindPopup(() => createPopupContent(slot, marker));
                  marker.on('popupopen', (e) => {
                    onPopupOpen(e, slot, marker);
                  });
                  markerClusterGroup.addLayer(marker);
                }
              }
            });

            index += chunkSize;
            if (index < parkingData.length) {
              setTimeout(processChunk, 0);  // Use setTimeout instead of requestAnimationFrame
            }
          }

          processChunk();
          map.addLayer(markerClusterGroup);

          // Debounce the moveend event to prevent too frequent updates
          let moveTimeout;
          map.on('moveend', () => {
            if (moveTimeout) clearTimeout(moveTimeout);
            moveTimeout = setTimeout(() => {
              const bounds = map.getBounds().pad(0.5);
              parkingData.forEach(slot => {
                const { lat, lon } = convertToWGS84(slot.x, slot.y);
                if (bounds.contains([lat, lon]) && !markers[slot.id]) {
                  const marker = L.marker([lat, lon], { icon: busyIcon });
                  markers[slot.id] = marker;
                  marker.bindPopup(() => createPopupContent(slot, marker));
                  marker.on('popupopen', (e) => {
                    onPopupOpen(e, slot, marker);
                  });
                  markerClusterGroup.addLayer(marker);
                }
              });
            }, 250);  // Wait 250ms after movement stops before updating
          });
        })
        .catch(error => console.error('Error loading parking data:', error));
    }
    

    // Uncomment the appropriate function call:
    // For a real backend:
    // loadParkingSlots();
    // For demo purposes:
    loadParkingSlotsDemo();

  </script>
</body>
</html>
